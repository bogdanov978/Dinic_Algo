#pragma once
# include <list>//используется для хранения исходящих из вершины ребер
# include <deque>// контейнер наиболее удобен при реализации поиска в ширину
# include <fstream>
template<class T>
const T& min(const T& a, const T& b)
{
	return (b < a) ? b : a;
}
typedef int n_type;// тип данных, используемый для указания пропускных способностей, должен быть знаковым, предполагается, что целочисленный (в случае дробных значений необходимо будет изменить условия проверки величины на равенство 0 и, следовательно ввести дополнительную величину e>0)
typedef unsigned int uint;// беззнаковый целочисленный тип данных, используемый для индексации
class Dinic_Graph
{
private:
	n_type INF;// величина, которую принимаем за бесконечность
	struct edge // структура, описывающая ребро
	{
		uint l; // номер вершины-начала
		uint r; // номер вершины-конца
		n_type max; // максимальная пропускная способность
		n_type cur; // текущий поток ребра
		edge* rev; // указатель на обратное ребро
	};
	struct vertex // структура-вершина графа 
	{
		std::list<edge> edges; // характеризуется набором исходящих из вершины ребер (как прямых, так и обратных) 
		//список выбран по причине простоты добавления очередного элемента при вводе графа (при этом сохраняя указатели);
		//так как ребра вершины обрабатываются все и последовательно, невозможность эффективного произвольного доступа не является недостатком.
		uint dist; // дистанция от вершины до вершины-истока. Значение 0 означает, что дистанция не определена (вершина не была посещена при поиске в ширину).
	};
	uint V; // количество вершин в графе
	uint source; // номер вершины-истока
	uint sink;   // номер вершины-стока
	vertex* graph; // массив элементов типа "вершина"
	bool Breadth_First_Search();//обход графа в ширину, поиск пути из истока в сток, расстановка дистанций вершин
	n_type Depth_First_Search(uint cur_vert, n_type flow);//обход в глубину с текущей расстановкой дистанций
public:
	Dinic_Graph(n_type infinity, std::istream& input);// конструктор, принимает величину, используемую в качестве бесконечности и входной поток.
	Dinic_Graph(const Dinic_Graph& obj); //конструктор копирования и оператор присваивания не используются в клиенте,
	Dinic_Graph& operator=(const Dinic_Graph& rvl);//но реализованы из-за наличия динамически выделяемой памяти (graph) и указателей(edge::rev)
	~Dinic_Graph();

	n_type Find_Max_Flow(std::ostream& out);// возвращает максимальную величину потока в сети, в качестве аргумента принимает выходной поток для вывода итераций алгоритма
	friend std::istream& operator>>(std::istream& in, Dinic_Graph& obj); // оператор потокового ввода, принимает данные в следующем формате:
	//V E sourse sink (количество вершин, количество ребер, номер вершины-источника, номер вершины-стока)
	//далее E строк в виде (l r max) (вершина-начало, вершина-конец, максимальная пропускная способность)
	friend std::ostream& operator<<(std::ostream& out, const Dinic_Graph& obj);
};